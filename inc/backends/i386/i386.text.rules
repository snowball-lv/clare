


#define OP(...)     HEAP(PAsmOp, __VA_ARGS__)
#define NTYPE(nt, action)   RULE({ return root->type == nt; }, action)


NTYPE(IR_NT_Seq, {
    MUNCH(root->kids[0]);
    MUNCH(root->kids[1]);
})

RULE({
    if (
        root->type == IR_NT_Mov &&
        root->kids[0]->type == IR_NT_Tmp && 
        root->kids[0]->data_type == IR_DT_I32 &&
        root->kids[1]->data_type == IR_DT_I32
    ) { return 1; }
}, {
    Node *tmp_dst = root->kids[0];
    PAsmVReg *dst = GetOrCreateVReg(state, tmp_dst);
    PAsmVReg *src = MUNCH(root->kids[1]);
    EMIT(OP({
        .fmt = "mov $vr, $vr\n",
        .oprs[0] = { .vreg = dst },
        .oprs[1] = { .vreg = src },
        .use = { src },
        .def = { dst }
    }));
})

RULE({
    if (
        root->type == IR_NT_Tmp && root->data_type == IR_DT_I32
    ) { return 1; }
}, {
    return GetOrCreateVReg(state, root);
})

RULE({
    if (
        root->type == IR_NT_Arg && root->data_type == IR_DT_I32
    ) { return 1; }
}, {
    PAsmVReg *vreg = NewPAsmVReg();
    EMIT(OP({
        .fmt = "mov $vr, [$vr + $i32]\n",
        .oprs[0] = { .vreg = vreg },
        .oprs[1] = { .vreg = EBP },
        .oprs[2] = { .i32 = 8 + root->arg_index * 4 },
        .def = { vreg },
        .use = { EBP }
    }));
    return vreg;
})

NTYPE(IR_NT_I32, {
    PAsmVReg *vreg = NewPAsmVReg();
    EMIT(OP({
        .fmt = "mov $vr, $i32\n",
        .oprs[0] = { .vreg = vreg },
        .oprs[1] = { .i32 = root->i32 },
        .def = { vreg }
    }));
    return vreg;
})

RULE({
    if (
        root->type == IR_NT_Add &&
        root->kids[0]->data_type == IR_DT_I32 &&
        root->kids[1]->data_type == IR_DT_I32
    ) { return 1; }
}, {
    PAsmVReg *left = MUNCH(root->kids[0]);
    PAsmVReg *right = MUNCH(root->kids[1]);
    PAsmVReg *tmp = NewPAsmVReg();
    EMIT(OP({
        .fmt = "mov $vr, $vr\n",
        .oprs[0] = { .vreg = tmp },
        .oprs[1] = { .vreg = left },
        .use = { left },
        .def = { tmp }
    }));
    EMIT(OP({
        .fmt = "add $vr, $vr\n",
        .oprs[0] = { .vreg = tmp },
        .oprs[1] = { .vreg = right },
        .use = { tmp, right },
        .def = { tmp }
    }));
    return tmp;
})

RULE({
    if (
        root->type == IR_NT_Ret &&
        root->kids[0]->data_type == IR_DT_I32
    ) { return 1; }
}, {
    PAsmVReg *vreg = MUNCH(root->kids[0]);
    EMIT(OP({
        .fmt = "mov $vr, $vr\n",
        .oprs[0] = { .vreg = EAX },
        .oprs[1] = { .vreg = vreg },
        .use = { vreg },
        .def = { EAX }
    }));
    EMIT(OP({
        .fmt = "jmp .epilogue\n",
        .use = { EAX },
        .is_ret = 1
    }));
})

NTYPE(IR_NT_Nop, {
    // do nothing
})

NTYPE(IR_NT_Eq, {
    PAsmVReg *left = MUNCH(root->kids[0]);
    PAsmVReg *right = MUNCH(root->kids[1]);
    EMIT(OP({
        .fmt = "cmp $vr, $vr\n",
        .oprs[0] = { .vreg = left },
        .oprs[1] = { .vreg = right },
        .use = { left, right}
    }));
})

NTYPE(IR_NT_Lt, {
    PAsmVReg *left = MUNCH(root->kids[0]);
    PAsmVReg *right = MUNCH(root->kids[1]);
    EMIT(OP({
        .fmt = "cmp $vr, $vr\n",
        .oprs[0] = { .vreg = left },
        .oprs[1] = { .vreg = right },
        .use = { left, right}
    }));
})

RULE({
    if (root->type == IR_NT_Branch) {
        if (root->kids[0]->type == IR_NT_Eq) {
            return 1;
        }
    }
}, {
    
    MUNCH(root->kids[0]);
    
    int label_true  = NextLabel(state);
    int label_end   = NextLabel(state);
    
    EMIT(OP({
        .fmt = "je .L_T_$i32\n",
        .oprs[0] = { .i32 = label_true },
        .is_jump = 1,
        .is_cjump = 1,
        .label_id = label_true
    }));
    
    // false
    MUNCH(root->kids[2]);
    
    EMIT(OP({
        .fmt = "jmp .L_E_$i32\n",
        .oprs[0] = { .i32 = label_end },
        .is_jump = 1,
        .label_id = label_end
    }));
    
    EMIT(OP({
        .fmt = ".L_T_$i32:\n",
        .oprs[0] = { .i32 = label_true },
        .is_label = 1,
        .label_id = label_true
    }));
    
    // true
    MUNCH(root->kids[1]);
    
    EMIT(OP({
        .fmt = ".L_E_$i32:\n",
        .oprs[0] = { .i32 = label_end },
        .is_label = 1,
        .label_id = label_end
    }));
    
})

RULE({
    if (root->type == IR_NT_Branch) {
        if (root->kids[0]->type == IR_NT_Lt) {
            return 1;
        }
    }
}, {
    
    MUNCH(root->kids[0]);
    
    int label_true  = NextLabel(state);
    int label_end   = NextLabel(state);
    
    EMIT(OP({
        .fmt = "jl .L_T_$i32\n",
        .oprs[0] = { .i32 = label_true },
        .is_jump = 1,
        .is_cjump = 1,
        .label_id = label_true
    }));
    
    // false
    MUNCH(root->kids[2]);
    
    EMIT(OP({
        .fmt = "jmp .L_E_$i32\n",
        .oprs[0] = { .i32 = label_end },
        .is_jump = 1,
        .label_id = label_end
    }));
    
    EMIT(OP({
        .fmt = ".L_T_$i32:\n",
        .oprs[0] = { .i32 = label_true },
        .is_label = 1,
        .label_id = label_true
    }));
    
    // true
    MUNCH(root->kids[1]);
    
    EMIT(OP({
        .fmt = ".L_E_$i32:\n",
        .oprs[0] = { .i32 = label_end },
        .is_label = 1,
        .label_id = label_end
    }));
    
})

RULE({
    if (root->type == IR_NT_Loop) {
        if (root->kids[0]->type == IR_NT_Eq) {
            return 1;
        }
    }
}, {
    
    int label_start = NextLabel(state);
    
    EMIT(OP({
        .fmt = ".L_S_$i32:\n",
        .oprs[0] = { .i32 = label_start },
        .is_label = 1,
        .label_id = label_start
    }));
    
    MUNCH(root->kids[0]);
    
    int label_end = NextLabel(state);
    
    EMIT(OP({
        .fmt = "jne .L_E_$i32\n",
        .oprs[0] = { .i32 = label_end },
        .is_jump = 1,
        .is_cjump = 1,
        .label_id = label_end
    }));
    
    // true
    MUNCH(root->kids[1]);
    
    EMIT(OP({
        .fmt = "jmp .L_S_$i32\n",
        .oprs[0] = { .i32 = label_start },
        .is_jump = 1,
        .label_id = label_start
    }));
    
    EMIT(OP({
        .fmt = ".L_E_$i32:\n",
        .oprs[0] = { .i32 = label_end },
        .is_label = 1,
        .label_id = label_end
    }));
})

RULE({
    if (root->type == IR_NT_Loop) {
        if (root->kids[0]->type == IR_NT_Lt) {
            return 1;
        }
    }
}, {
    
    int label_start = NextLabel(state);
    
    EMIT(OP({
        .fmt = ".L_S_$i32:\n",
        .oprs[0] = { .i32 = label_start },
        .is_label = 1,
        .label_id = label_start
    }));
    
    MUNCH(root->kids[0]);
    
    int label_end = NextLabel(state);
    
    EMIT(OP({
        .fmt = "jnl .L_E_$i32\n",
        .oprs[0] = { .i32 = label_end },
        .is_jump = 1,
        .is_cjump = 1,
        .label_id = label_end
    }));
    
    // true
    MUNCH(root->kids[1]);
    
    EMIT(OP({
        .fmt = "jmp .L_S_$i32\n",
        .oprs[0] = { .i32 = label_start },
        .is_jump = 1,
        .label_id = label_start
    }));
    
    EMIT(OP({
        .fmt = ".L_E_$i32:\n",
        .oprs[0] = { .i32 = label_end },
        .is_label = 1,
        .label_id = label_end
    }));
})

NTYPE(IR_NT_Call, {

    LIST_REV(root->args, Node *, arg, {
        PAsmVReg *vreg = MUNCH(arg);
        EMIT(OP({ 
            .fmt = "push $vr\n",
            .oprs[0] = { .vreg = vreg },
            .use = { vreg }
        }));
    });
    
    EMIT(OP({
        .fmt = "call $str\n",
        .oprs[0] = { .str = root->fname },
        .use = { EAX, EDX, ECX },
        .def = { EAX }
    }));
    
    EMIT(OP({
        .fmt = "add $vr, $i32\n",
        .oprs[0] = { .vreg = ESP },
        .oprs[1] = { .i32 = ListSize(root->args) * 4 },
        .def = { ESP }
    }));
    
    PAsmVReg *tmp = NewPAsmVReg();
    EMIT(OP({
        .fmt = "mov $vr, $vr\n",
        .oprs[0] = { .vreg = tmp },
        .oprs[1] = { .vreg = EAX },
        .use = { EAX },
        .def = { tmp }
    }));
    return tmp;
})


RULE({ return 1; }, {
    ERROR(
        "No matching instruction selection rule!\n"
        "Node: %s, Type %s\n",
        NodeName(root),
        IRDataTypeName(root->data_type));
})


#undef NTYPE
#undef OP
