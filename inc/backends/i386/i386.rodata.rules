

#define OP(...)     HEAP(PAsmOp, __VA_ARGS__)
#define NTYPE(nt, action)   RULE({ return root->type == nt; }, action)


NTYPE(IR_NT_Seq, {
    MUNCH(root->kids[0]);
    MUNCH(root->kids[1]);
})

RULE({
    if (root->type == IR_NT_Mov) {
        if (root->kids[0]->type == IR_NT_Tmp) {
            return 1;
        }
    }
}, {
    MUNCH(root->kids[1]);
})

NTYPE(IR_NT_Add, {
    MUNCH(root->kids[0]);
    MUNCH(root->kids[1]);
})

NTYPE(IR_NT_Tmp, {

})

NTYPE(IR_NT_Arg, {
    
})

NTYPE(IR_NT_I32, {
    
})

NTYPE(IR_NT_Float, {
    EMIT(OP({
        .fmt = "_const_f_$f: dd $f\n",
        .oprs[0] = { .f = root->f },
        .oprs[1] = { .f = root->f }
    }));
})

NTYPE(IR_NT_Ret, {
    MUNCH(root->kids[0]);
})

NTYPE(IR_NT_Nop, {
    // do nothing
})

NTYPE(IR_NT_Eq, {
    MUNCH(root->kids[0]);
    MUNCH(root->kids[1]);
})

RULE({
    if (root->type == IR_NT_Branch) {
        if (root->kids[0]->type == IR_NT_Eq) {
            return 1;
        }
    }
}, {
    MUNCH(root->kids[0]);
    MUNCH(root->kids[2]);
    MUNCH(root->kids[1]);
})

NTYPE(IR_NT_Call, {
    LIST_REV(root->args, Node *, arg, {
        MUNCH(arg);
    });
})

RULE({ return 1; }, {
    ERROR(
        "No matching instruction selection rule!\n"
        "Node: %s, Type %s\n",
        NodeName(root),
        IRDataTypeName(root->data_type));
})


#undef NTYPE
#undef OP
