

#define OP(...)     HEAP(PAsmOp, __VA_ARGS__)

RULE(IR.Seq(0, 0), {
    MUNCH(root->kids[0]);
    MUNCH(root->kids[1]);
})

RULE(IR.Mov(IR.Tmp(), 0), {
    Node *tmp_dst = root->kids[0];
    PAsmVReg *dst = PAsmVRegFromTmp(tmp_dst);
    PAsmVReg *src = MUNCH(root->kids[1]);
    EMIT(OP({
        .fmt = "mov $vr, $vr\n",
        .oprs[0] = { .vreg = dst },
        .oprs[1] = { .vreg = src },
        .use = { src },
        .def = { dst }
    }));
})

RULE(IR.Add(IR.I32(0), IR.I32(0)), {
    PAsmVReg *a = MUNCH(root->kids[0]);
    PAsmVReg *b = MUNCH(root->kids[1]);
    EMIT(OP({
        .fmt = "add $vr, $vr\n",
        .oprs[0] = { .vreg = a },
        .oprs[1] = { .vreg = b },
        .use = { a, b },
        .def = { a }
    }));
    return a;
})

RULE(IR.Tmp(), {
    return PAsmVRegFromTmp(root);
})

RULE(IR.Arg(0), {
    PAsmVReg *vreg = NewPAsmVReg();
    EMIT(OP({
        .fmt = "mov $vr, [$vr + $i32]\n",
        .oprs[0] = { .vreg = vreg },
        .oprs[1] = { .vreg = EBP },
        .oprs[2] = { .i32 = 8 + root->arg_index * 4 },
        .def = { vreg },
        .use = { EBP }
    }));
    return vreg;
})

RULE(IR.I32(0), {
    PAsmVReg *vreg = NewPAsmVReg();
    EMIT(OP({
        .fmt = "mov $vr, $i32\n",
        .oprs[0] = { .vreg = vreg },
        .oprs[1] = { .i32 = root->i32 },
        .def = { vreg }
    }));
    return vreg;
})

RULE(IR.Float(0), {
    EMIT(OP({
        .fmt = "fld dword [_const_$f]\n",
        .oprs[0] = { .f = root->f }
    }));
})

RULE(IR.Add(IR.Float(0), IR.Float(0)), {
    MUNCH(root->kids[0]);
    MUNCH(root->kids[1]);
    EMIT(OP({
        .fmt = "faddp\n"
    }));
})

RULE(IR.Add(0, 0), {
    PAsmVReg *left = MUNCH(root->kids[0]);
    PAsmVReg *right = MUNCH(root->kids[1]);
    if (left == 0 && right == 0) {
        EMIT(OP({
            .fmt = "faddp\n"
        }));
    } else {
        EMIT(OP({
            .fmt = "add $vr, $vr\n",
            .oprs[0] = { .vreg = left },
            .oprs[1] = { .vreg = right },
            .use = { left, right },
            .def = { left }
        }));
        return left;
    }
})

RULE(IR.Ret(0), {
    
    PAsmVReg *vreg = MUNCH(root->kids[0]);
    
    if (vreg != 0) {
        EMIT(OP({
            .fmt = "mov $vr, $vr\n",
            .oprs[0] = { .vreg = EAX },
            .oprs[1] = { .vreg = vreg },
            .use = { vreg },
            .def = { EAX }
        }));
    } else {
        // nothing
    }
    
    EMIT(OP({
        .fmt = "mov $vr, $vr\n",
        .oprs[0] = { .vreg = ESP },
        .oprs[1] = { .vreg = EBP },
        .use = { EBP },
        .def = { ESP }
    }));
    EMIT(OP({ 
        .fmt = "pop $vr\n",
        .oprs[0] = { .vreg = EBP },
        .def = { EBP }
    }));
    
    EMIT(OP({
        .fmt = "ret\n",
        .use = { EAX },
        .is_ret = 1
    }));
})

RULE(IR.Nop(), {
    // do nothing
})

RULE(IR.Eq(0, 0), {
    PAsmVReg *left = MUNCH(root->kids[0]);
    PAsmVReg *right = MUNCH(root->kids[1]);
    EMIT(OP({
        .fmt = "cmp $vr, $vr\n",
        .oprs[0] = { .vreg = left },
        .oprs[1] = { .vreg = right },
        .use = { left, right}
    }));
})

RULE(IR.Lt(0, 0), {
    PAsmVReg *left = MUNCH(root->kids[0]);
    PAsmVReg *right = MUNCH(root->kids[1]);
    EMIT(OP({
        .fmt = "cmp $vr, $vr\n",
        .oprs[0] = { .vreg = left },
        .oprs[1] = { .vreg = right },
        .use = { left, right}
    }));
})

RULE(IR.Branch(IR.Eq(0, 0), 0, 0), {
    
    MUNCH(root->kids[0]);
    
    int label_true  = NextLabel();
    int label_end   = NextLabel();
    
    EMIT(OP({
        .fmt = "je .L_T_$i32\n",
        .oprs[0] = { .i32 = label_true },
        .is_jump = 1,
        .is_cjump = 1,
        .label_id = label_true
    }));
    
    // false
    MUNCH(root->kids[2]);
    
    EMIT(OP({
        .fmt = "jmp .L_E_$i32\n",
        .oprs[0] = { .i32 = label_end },
        .is_jump = 1,
        .label_id = label_end
    }));
    
    EMIT(OP({
        .fmt = ".L_T_$i32:\n",
        .oprs[0] = { .i32 = label_true },
        .is_label = 1,
        .label_id = label_true
    }));
    
    // true
    MUNCH(root->kids[1]);
    
    EMIT(OP({
        .fmt = ".L_E_$i32:\n",
        .oprs[0] = { .i32 = label_end },
        .is_label = 1,
        .label_id = label_end
    }));
    
})

RULE(IR.Branch(IR.Lt(0, 0), 0, 0), {
    
    MUNCH(root->kids[0]);
    
    int label_true  = NextLabel();
    int label_end   = NextLabel();
    
    EMIT(OP({
        .fmt = "jl .L_T_$i32\n",
        .oprs[0] = { .i32 = label_true },
        .is_jump = 1,
        .is_cjump = 1,
        .label_id = label_true
    }));
    
    // false
    MUNCH(root->kids[2]);
    
    EMIT(OP({
        .fmt = "jmp .L_E_$i32\n",
        .oprs[0] = { .i32 = label_end },
        .is_jump = 1,
        .label_id = label_end
    }));
    
    EMIT(OP({
        .fmt = ".L_T_$i32:\n",
        .oprs[0] = { .i32 = label_true },
        .is_label = 1,
        .label_id = label_true
    }));
    
    // true
    MUNCH(root->kids[1]);
    
    EMIT(OP({
        .fmt = ".L_E_$i32:\n",
        .oprs[0] = { .i32 = label_end },
        .is_label = 1,
        .label_id = label_end
    }));
    
})

RULE(IR.Loop(IR.Eq(0, 0), 0), {
    
    int label_start = NextLabel();
    
    EMIT(OP({
        .fmt = ".L_S_$i32:\n",
        .oprs[0] = { .i32 = label_start },
        .is_label = 1,
        .label_id = label_start
    }));
    
    MUNCH(root->kids[0]);
    
    int label_end = NextLabel();
    
    EMIT(OP({
        .fmt = "jne .L_E_$i32\n",
        .oprs[0] = { .i32 = label_end },
        .is_jump = 1,
        .is_cjump = 1,
        .label_id = label_end
    }));
    
    // true
    MUNCH(root->kids[1]);
    
    EMIT(OP({
        .fmt = "jmp .L_S_$i32\n",
        .oprs[0] = { .i32 = label_start },
        .is_jump = 1,
        .label_id = label_start
    }));
    
    EMIT(OP({
        .fmt = ".L_E_$i32:\n",
        .oprs[0] = { .i32 = label_end },
        .is_label = 1,
        .label_id = label_end
    }));
})

RULE(IR.Loop(IR.Lt(0, 0), 0), {
    
    int label_start = NextLabel();
    
    EMIT(OP({
        .fmt = ".L_S_$i32:\n",
        .oprs[0] = { .i32 = label_start },
        .is_label = 1,
        .label_id = label_start
    }));
    
    MUNCH(root->kids[0]);
    
    int label_end = NextLabel();
    
    EMIT(OP({
        .fmt = "jnl .L_E_$i32\n",
        .oprs[0] = { .i32 = label_end },
        .is_jump = 1,
        .is_cjump = 1,
        .label_id = label_end
    }));
    
    // true
    MUNCH(root->kids[1]);
    
    EMIT(OP({
        .fmt = "jmp .L_S_$i32\n",
        .oprs[0] = { .i32 = label_start },
        .is_jump = 1,
        .label_id = label_start
    }));
    
    EMIT(OP({
        .fmt = ".L_E_$i32:\n",
        .oprs[0] = { .i32 = label_end },
        .is_label = 1,
        .label_id = label_end
    }));
})

RULE(IR.Call(0, 0), {
    
    LIST_REV(root->args, Node *, arg, {
        PAsmVReg *vreg = MUNCH(arg);
        EMIT(OP({ 
            .fmt = "push $vr\n",
            .oprs[0] = { .vreg = vreg },
            .use = { vreg }
        }));
    });
    
    EMIT(OP({
        .fmt = "call $str\n",
        .oprs[0] = { .str = root->fname },
        .use = { EAX, EDX, ECX },
        .def = { EAX }
    }));
    
    EMIT(OP({
        .fmt = "add $vr, $i32\n",
        .oprs[0] = { .vreg = ESP },
        .oprs[1] = { .i32 = ListSize(root->args) * 4 },
        .def = { ESP }
    }));
    
    return EAX;
})

RULE(IR.Any(), {
    printf("no instruction selection rule for: %s\n", NodeName(root));
})

#undef OP
