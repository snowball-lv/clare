

RULE(IR.Dummy(), {
    printf("dummy\n");
})

RULE(IR.Branch(0, 0 ,0), {
    
    Label *t = NewLabelNamed("true");
    Label *f = NewLabelNamed("false");
    Label *end = NewLabelNamed("end");
    
    MunchTF(NodeChild(root, 0), t, f);
    
    printf("%s:\n", t);
    Emit(HEAP(Op, {
        .fmt = "$l:\n",
        .oprs[0].label = t
    }));
    
    Munch(NodeChild(root, 1));
    
    printf("jmp %s\n", end);
    Emit(HEAP(Op, {
        .fmt = "jmp $l\n",
        .oprs[0].label = end
    }));
    
    printf("%s:\n", f);
    Emit(HEAP(Op, {
        .fmt = "$l:\n",
        .oprs[0].label = f
    }));
    
    Munch(NodeChild(root, 2));
    
    printf("jmp %s\n", end);
    Emit(HEAP(Op, {
        .fmt = "jmp $l\n",
        .oprs[0].label = end
    }));
    
    printf("%s:\n", end);
    Emit(HEAP(Op, {
        .fmt = "$l:\n",
        .oprs[0].label = end
    }));
})

RULE(IR.Eq(0, 0), {
    
    VReg *a = Munch(NodeChild(root, 0));
    VReg *b = Munch(NodeChild(root, 1));
    
    printf(
        "cmp $vr%d, $vr%d\n",
        a->index,
        b->index);
    printf("je %s\n", tl);
    printf("jmp %s\n", fl);
})

RULE(IR.I32(0), {
    
    VReg *vreg = NewVReg();
    
    printf(
        "mov $vr%d, %d\n",
        vreg->index,
        IR.GetI32(root));
        
    Emit(HEAP(Op, {
        .fmt = "mov $vr, $i32\n",
        .oprs[0].index = vreg->index,
        .oprs[1].i32 = IR.GetI32(root)
    }));
        
    return vreg;
})

RULE(IR.Arg(0), {
    VReg *vreg = NewVReg();
    int index = IR.GetArgIndex(root);
    printf(
        "mov $vr%d, [ebp + %d]\n",
        vreg->index,
        8 + index * 4);
    return vreg;
})

RULE(IR.Ret(0), {
    VReg *vreg = Munch(NodeChild(root, 0));
    printf("mov eax, $vr%d\n", vreg->index);
    printf("ret\n");
})

RULE(IR.Add(0, 0), {
    VReg *left = Munch(NodeChild(root, 0));
    VReg *right = Munch(NodeChild(root, 1));
    printf(
        "add $vr%d, $vr%d\n",
        left->index,
        right->index);
    return left;
})

RULE(IR.Call(0, 0), {
    
    List *args = IR.GetArgs(root);
    
    LIST_EACH(IR.GetArgs(root), Node *, arg_node, {
        VReg *arg = Munch(arg_node);
        printf("push $vr%d\n", arg->index);
    });
    
    printf("call %s\n", IR.GetFuncName(root));
    printf("add esp, %d\n", ListSize(args) * 4);
    
    VReg *vreg = NewVReg();
    printf("mov $vr%d, eax\n", vreg->index);
    return vreg;
})
