

#define MUNCH_F       MANGLE(Munch)
#define MUNCH_F2      MUNCH_F ## 2


#ifdef STATE
    static RET_TYPE MUNCH_F2(Node *root, List *patterns, List *ops, STATE_T *state) 
#else
    static RET_TYPE MUNCH_F2(Node *root, List *patterns, List *ops) 
#endif
{
    
    int _index = 0;
    
    #ifdef STATE
        #define MUNCH(node)     MUNCH_F2(node, patterns, ops, state)
    #else
        #define MUNCH(node)     MUNCH_F2(node, patterns, ops)
    #endif
    
    #define EMIT(op)        ListAdd(ops, op)
    
    #define RULE(pattern, action) {             \
        Node *p = ListGet(patterns, _index);    \
        if (NodeMatch(root, p)) {               \
            action;                             \
            return RET_DEFAULT;                 \
        }                                       \
        _index++;                               \
    }
        #include RULE_FILE
    #undef RULE
    
    #undef EMIT
    #undef MUNCH
        
    printf("Trying to match node: %s\n", NodeName(root));
    assert(0 && "No rule matches node");
}

List *MUNCH_F(Node *root) {
    
    #ifdef STATE
        STATE_T _state = { 0 };
        STATE_T *state = &_state;
        STATE_INIT;
    #endif
    
    List *ops = NewList();
    List *patterns = NewList();
    
    #define RULE(pattern, action)   ListAdd(patterns, pattern);
        #include RULE_FILE
    #undef RULE
    
    #ifdef STATE
        MUNCH_F2(root, patterns, ops, state);
    #else
        MUNCH_F2(root, patterns, ops);
    #endif
    
    LIST_EACH(patterns, Node *, pattern, {
        NodeDeleteTree(pattern);
    });
    DeleteList(patterns);
    
    #ifdef STATE
        STATE_DEINIT;
    #endif
    
    return ops;
}

#undef MUNCH_F
#undef MUNCH_F2
